package com.alinz.parkerdan.shareextension;

import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.WritableNativeMap;
import android.app.Activity;
import android.content.ContentResolver;
import android.content.CursorLoader;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;

import android.graphics.Bitmap;
import android.os.Build;
import android.os.Environment;
import android.provider.MediaStore;
import android.provider.OpenableColumns;
import android.util.Base64;
import android.util.Log;
import android.webkit.MimeTypeMap;
import android.widget.TextView;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Date;


public class ShareModule extends ReactContextBaseJavaModule {
    private boolean includeBase64 = true;
    private final ReactApplicationContext reactContext;
    private String url;
    private Uri uri;
    private String type;
    private String extension = "";
  public ShareModule(ReactApplicationContext reactContext) {
      super(reactContext);
      this.reactContext = reactContext;
  }

  @Override
  public String getName() {
      return "ReactNativeShareExtension";
  }

  @ReactMethod
    public void close() {

        Activity currentActivity = getCurrentActivity();

        getCurrentActivity().finish();
    }
    @ReactMethod
    public void getIntentAction(Promise promise) {

        Activity currentActivity = getCurrentActivity();
        Intent intent = currentActivity.getIntent();
        String action = intent.getAction();

        WritableMap map = Arguments.createMap();
        boolean isActionSend = Intent.ACTION_SEND.equals(action);
        map.putString("intentAction",  action);
        map.putBoolean("isActionSend",   isActionSend);
        promise.resolve(map);
    }

  @ReactMethod
  public void data(Promise promise) {
      promise.resolve(processIntent());
  }

  public WritableMap processIntent() {
      WritableMap map = Arguments.createMap();

      String value = "";
      String type = "";
      String action = "";

      Activity currentActivity = getCurrentActivity();

      if (currentActivity != null) {
          Intent intent = currentActivity.getIntent();
          this.uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);

          try {
              return getFileSelection(currentActivity);
          } catch (Exception e) {
              e.printStackTrace();
              map.putString("mediaId",  String.format("file_%d",  new Date().getTime()));
              map.putString("mediaPath", "");
              map.putInt("mediaSize", 0);
              map.putString("mediaMimeType", "");
              map.putString("mediaName", "");
              map.putString("data", "");
              return map;
          }
//        if (Intent.ACTION_SEND.equals(action) && "text/plain".equals(type)) {
//          value = intent.getStringExtra(Intent.EXTRA_TEXT);
//        }
//        else if (Intent.ACTION_SEND.equals(action) && ("image/*".equals(type) || "image/jpeg".equals(type) || "image/png".equals(type) || "image/jpg".equals(type) ) ) {
//          Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
//         value = "file://" + RealPathUtil.getRealPathFromURI(currentActivity, uri);
//
//       } else {
//         value = "";
//       }

      } else {
          map.putString("mediaId",  String.format("file_%d",  new Date().getTime()));
          map.putString("mediaPath", "");
          map.putInt("mediaSize", 0);
          map.putString("mediaMimeType", "");
          map.putString("mediaName", "");
          map.putString("data", "");
          return map;
      }


  }
    private String resolveRealPath(Activity activity) {
        String path = null;
        if(isFile())
        {
            return getFilePath(activity);
        }
        return path;
    }

    private static String getMimeType(String url) {
        String type = null;
        String extension = MimeTypeMap.getFileExtensionFromUrl(url);
        if (extension != null) {
            type = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
        }
        return type;
    }

    private WritableMap getFileSelection(Activity activity) throws Exception {

        WritableMap map = new WritableNativeMap();

        String filePath = null;
        String mimeType = activity.getIntent().getType();
        String fileName= System.currentTimeMillis() + "." + MimeTypeMap.getFileExtensionFromUrl(uri.toString());
        String scheme = uri.getScheme();
        int size = 0;
        if (scheme != null && scheme.equals("content")) {
            Cursor  returnCursor = reactContext.getContentResolver().query(uri, null, null, null, null);

            try {
                if (returnCursor != null && returnCursor.moveToFirst()) {
                    int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
                    int sizeIndex = returnCursor.getColumnIndex(OpenableColumns.SIZE);
                    int mimeTypeIndex = returnCursor.getColumnIndex("mime_type");
                   if(nameIndex > -1 )
                   {
                       fileName = returnCursor.getString(nameIndex);
                   }
                    else
                   {
                       fileName = uri.getPath();
                       int cut = fileName.lastIndexOf('/');
                       if (cut != -1 && !fileName.substring(cut + 1).equals("ROW")) {
                           fileName = fileName.substring(cut + 1);
                       }
                   }

                   if(mimeTypeIndex >-1)
                   {
                       mimeType = returnCursor.getString(mimeTypeIndex);
                   }

                    if(sizeIndex >-1)
                    {
                        size = Integer.parseInt(returnCursor.getString(sizeIndex));
                    }


                }
                InputStream fileStream =  reactContext.getContentResolver().openInputStream(this.uri);
                File dir = new File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS );
                if (!dir.exists()) {
                    dir.mkdirs();
                }

                File file = new File(dir, fileName);
                copyInputStreamToFile(fileStream, file);
                if(size == 0)
                {
                    size =  (int)file.length();
                }

                map.putString("mediaId",  String.format("file_%d",  new Date().getTime()));
                map.putString("mediaPath", "file://" + file.getPath());
                map.putInt("mediaSize", size);
                map.putString("mediaMimeType", mimeType);
                map.putString("mediaName", file.getName());

            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
            finally {
                returnCursor.close();
            }

        }
        else
        {

            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
                filePath= RealPathUtil.getRealPathFromURI(activity, this.uri);
            } else {
                filePath= RealPathUtil.getRealPathFromURI(activity, this.uri);
            }

            if (filePath.startsWith("http://") || filePath.startsWith("https://")) {
                map.putString("mediaId",  String.format("file_%d",  new Date().getTime()));
                map.putString("mediaPath", "");
                map.putInt("mediaSize", 0);
                map.putString("mediaMimeType", "");
                map.putString("mediaName", "");
                map.putString("data", "");
                return map;
                }

                File file = new File(filePath);
                String mime = getMimeType(filePath);
                size = (int)file.length();
                map.putString("mediaId", String.format("file_%d", new Date().getTime()));
                map.putString("mediaPath", "file://" + filePath);
                map.putInt("mediaSize", size);
                map.putString("mediaMimeType", mime);
                map.putString("mediaName", file.getName());
                if (includeBase64) {
                    map.putString("data", getBase64StringFromFile(filePath));
                }
            }

        return  map;
    }
   
    private String getBase64StringFromFile(String absoluteFilePath) {
        InputStream inputStream;

        try {
            inputStream = new FileInputStream(new File(absoluteFilePath));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        }

        byte[] bytes;
        byte[] buffer = new byte[8192];
        int bytesRead;
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        try {
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        bytes = output.toByteArray();
        return Base64.encodeToString(bytes, Base64.NO_WRAP);
    }
    /**
     * Return an if the url is a file (local or base64)l
     * @return {@link boolean}
     */
    public boolean isFile() {
        return this.isBase64File() || this.isLocalFile();
    }
    public boolean isBase64File() {
        String scheme = uri.getScheme();
        if((scheme != null) && uri.getScheme().equals("data")) {
            this.type = this.uri.getSchemeSpecificPart().substring(0, this.uri.getSchemeSpecificPart().indexOf(";"));
            return true;
        }
        return false;
    }
    public boolean isLocalFile() {
        String scheme = uri.getScheme();
        if((scheme != null) && (uri.getScheme().equals("content") || uri.getScheme().equals("file"))) {
            // type is already set
            if (this.type != null) {
                return true;
            }
            // try to get mimetype from uri
            this.type = this.getMimeType(uri.toString());

            // try resolving the file and get the mimetype
            if(this.type == null) {
                String realPath = this.getRealPathFromURI(uri);
                if (realPath != null) {
                    this.type = this.getMimeType(realPath);
                } else {
                    return false;
                }
            }

            if(this.type == null) {
                this.type = "*/*";
            }

            return true;
        }
        return false;
    }
    public String getType() {
        if (this.type == null) {
            return "*/*";
        }
        return this.type;
    }
    private String getRealPathFromURI(Uri contentUri) {
        String[] proj = { MediaStore.Images.Media.DATA };
        CursorLoader loader = new CursorLoader(this.reactContext, contentUri, proj, null, null, null);
        Cursor cursor = loader.loadInBackground();
        String result = null;
        if (cursor != null && cursor.moveToFirst()) {
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            result = cursor.getString(column_index);
            cursor.close();
        }
        return result;
    }
    private String getFilePath(Activity activity) {

        String filePath = null;
        String scheme = uri.getScheme();
        if (scheme != null && scheme.equals("content")) {
            try {

                Cursor returnCursor = reactContext.getContentResolver().query(uri, null, null, null, null);

                if (returnCursor != null && returnCursor.moveToFirst()) {
                    int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
                    int sizeIndex = returnCursor.getColumnIndex(OpenableColumns.SIZE);
                    String fileName = returnCursor.getString(nameIndex);
                    Long fileSize = returnCursor.getLong(sizeIndex);
                    returnCursor.close();
                }

                InputStream fileStream =  reactContext.getContentResolver().openInputStream(this.uri);
                File dir = new File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS );
                if (!dir.exists()) {
                    dir.mkdirs();
                }
                File file = new File(dir, System.currentTimeMillis() + "." + this.extension);
                copyInputStreamToFile(fileStream, file);
                return  dir.getPath();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }


        }
        else
        {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
                filePath= RealPathUtil.getRealPathFromURI(activity, this.uri);
            } else {
                filePath= RealPathUtil.getRealPathFromURI(activity, this.uri);
            }
        }
        return filePath;
//        final MimeTypeMap mime = MimeTypeMap.getSingleton();
//        this.extension = mime.getExtensionFromMimeType(getType());
//        if(!this.isBase64File()) {
//            String encodedImg = this.uri.getSchemeSpecificPart().substring(this.uri.getSchemeSpecificPart().indexOf(";base64,") + 8);
//            try {
//                File dir = new File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS );
//                if (!dir.exists()) {
//                    dir.mkdirs();
//                }
//                File file = new File(dir, System.currentTimeMillis() + "." + this.extension);
//                final FileOutputStream fos = new FileOutputStream(file);
//                fos.write(Base64.decode(encodedImg, Base64.DEFAULT));
//                fos.flush();
//                fos.close();
//                return Uri.fromFile(file).getPath();
//
//            } catch (IOException e) {
//                e.printStackTrace();
//            }
//        } else if(this.isLocalFile()) {
//            String filePath = null;
//            String scheme = uri.getScheme();
//            if (scheme != null && scheme.equals("content")) {
//                try {
//
//                    Cursor returnCursor = reactContext.getContentResolver().query(uri, null, null, null, null);
//                    /*
//                     * Get the column indexes of the data in the Cursor,
//                     * move to the first row in the Cursor, get the data,
//                     * and display it.
//                     */
//                    int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
//                    int sizeIndex = returnCursor.getColumnIndex(OpenableColumns.SIZE);
//                    returnCursor.moveToFirst();
//                   // TextView nameView = (TextView) findViewById(R.id.filename_text);
//                    //TextView sizeView = (TextView) findViewById(R.id.filesize_text);
//                    String fileName =returnCursor.getString(nameIndex);
//                    String fileSize = Long.toString(returnCursor.getLong(sizeIndex));
//
//                    InputStream fileStream =  reactContext.getContentResolver().openInputStream(this.uri);
//                    File dir = new File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS );
//                    if (!dir.exists()) {
//                        dir.mkdirs();
//                    }
//                    File file = new File(dir, System.currentTimeMillis() + "." + this.extension);
//                    copyInputStreamToFile(fileStream, file);
//                    Log.w("myApp", "no network");
//                    return  dir.getPath();
//                } catch (FileNotFoundException e) {
//                    e.printStackTrace();
//                }
//
//
//            }
//           else
//            {
//                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
//                    filePath= RealPathUtil.getRealPathFromURI(activity, this.uri);
//                } else {
//                    filePath= RealPathUtil.getRealPathFromURI(activity, this.uri);
//                }
//            }
//            return filePath;
//
//        }
//        return null;
    }

    private void copyInputStreamToFile(InputStream in, File file) {
        OutputStream out = null;

        try {
            out = new FileOutputStream(file);
            byte[] buf = new byte[1024];
            int len;
            while((len=in.read(buf))>0){
                out.write(buf,0,len);
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            // Ensure that the InputStreams are closed even if there's an exception.
            try {
                if ( out != null ) {
                    out.close();
                }

                // If you want to close the "in" InputStream yourself then remove this
                // from here but ensure that you close it yourself eventually.
                in.close();
            }
            catch ( IOException e ) {
                e.printStackTrace();
            }
        }
    }
}
